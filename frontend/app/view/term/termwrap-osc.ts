import { RpcApi } from "@/app/store/wshclientapi";
import { TabRpcClient } from "@/app/store/wshrpcutil";
import { getApi, globalStore, WOS } from "@/store/global";
import * as services from "@/store/services";
import { sanitizeOsc7Path } from "@/util/pathutil";
import { base64ToString, fireAndForget } from "@/util/util";
import * as TermTypes from "@xterm/xterm";
import { Terminal } from "@xterm/xterm";
import debug from "debug";
import * as jotai from "jotai";

const dlog = debug("wave:termwrap");

const osc7DebounceMap = new Map<string, NodeJS.Timeout>();
const OSC7_DEBOUNCE_MS = 300;
const Osc52MaxDecodedSize = 75 * 1024;
const Osc52MaxRawLength = 128 * 1024;

function clearOsc7Debounce(tabId: string) {
    const existing = osc7DebounceMap.get(tabId);
    if (existing) {
        clearTimeout(existing);
        osc7DebounceMap.delete(tabId);
    }
}

export function cleanupOsc7DebounceForTab(tabId: string) {
    clearOsc7Debounce(tabId);
}

export interface OscHandlerContext {
    terminal: Terminal;
    nodeModel: { isFocused: jotai.Atom<boolean> } | null;
    promptMarkers: TermTypes.IMarker[];
    lastCommandAtom: jotai.PrimitiveAtom<string | null>;
    setShellIntegrationStatus(status: "ready" | "running-command" | null): void;
}

export type ShellIntegrationStatus = "ready" | "running-command";

type Osc16162Command =
    | { command: "A"; data: object }
    | { command: "C"; data: { cmd64?: string } }
    | { command: "M"; data: { shell?: string; shellversion?: string; uname?: string; integration?: boolean } }
    | { command: "D"; data: { exitcode?: number } }
    | { command: "I"; data: { inputempty?: boolean } }
    | { command: "R"; data: object };

export function handleOsc52Command(data: string, blockId: string, loaded: boolean, ctx: OscHandlerContext): boolean {
    if (!loaded) {
        return true;
    }
    const isBlockFocused = ctx.nodeModel ? globalStore.get(ctx.nodeModel.isFocused) : false;
    if (!document.hasFocus() || !isBlockFocused) {
        console.log("OSC 52: rejected, window or block not focused");
        return true;
    }
    if (!data || data.length === 0) {
        console.log("OSC 52: empty data received");
        return true;
    }
    if (data.length > Osc52MaxRawLength) {
        console.log("OSC 52: raw data too large", data.length);
        return true;
    }

    const semicolonIndex = data.indexOf(";");
    if (semicolonIndex === -1) {
        console.log("OSC 52: invalid format (no semicolon)", data.substring(0, 50));
        return true;
    }

    const clipboardSelection = data.substring(0, semicolonIndex);
    const base64Data = data.substring(semicolonIndex + 1);

    if (base64Data === "?") {
        console.log("OSC 52: clipboard query not supported");
        return true;
    }
    if (base64Data.length === 0) {
        return true;
    }
    if (clipboardSelection.length > 10) {
        console.log("OSC 52: clipboard selection too long", clipboardSelection);
        return true;
    }

    const estimatedDecodedSize = Math.ceil(base64Data.length * 0.75);
    if (estimatedDecodedSize > Osc52MaxDecodedSize) {
        console.log("OSC 52: data too large", estimatedDecodedSize, "bytes");
        return true;
    }

    try {
        const cleanBase64Data = base64Data.replace(/\s+/g, "");
        const decodedText = base64ToString(cleanBase64Data);
        const actualByteSize = new TextEncoder().encode(decodedText).length;
        if (actualByteSize > Osc52MaxDecodedSize) {
            console.log("OSC 52: decoded text too large", actualByteSize, "bytes");
            return true;
        }
        fireAndForget(async () => {
            try {
                await navigator.clipboard.writeText(decodedText);
                dlog("OSC 52: copied", decodedText.length, "characters to clipboard");
            } catch (err) {
                console.error("OSC 52: clipboard write failed:", err);
            }
        });
    } catch (e) {
        console.error("OSC 52: base64 decode error:", e);
    }

    return true;
}

export function handleOsc7Command(data: string, blockId: string, tabId: string, loaded: boolean): boolean {
    dlog("OSC 7 received:", { data, blockId, loaded });
    if (!loaded) {
        dlog("OSC 7 ignored - terminal not loaded");
        return true;
    }
    if (data == null || data.length == 0) {
        dlog("Invalid OSC 7 command received (empty)");
        return true;
    }
    if (data.length > 1024) {
        dlog("Invalid OSC 7, data length too long", data.length);
        return true;
    }

    let pathPart: string;
    try {
        const url = new URL(data);
        if (url.protocol !== "file:") {
            dlog("Invalid OSC 7 command received (non-file protocol)", data);
            return true;
        }
        // Only accept local file URLs (empty hostname or "localhost")
        if (url.hostname !== "" && url.hostname !== "localhost") {
            dlog("Invalid OSC 7 command received (non-local hostname)", data);
            return true;
        }
        pathPart = decodeURIComponent(url.pathname);
        if (/^[\\/]{2}[^\\/]/.test(pathPart)) {
            console.warn("[Security] UNC path blocked in OSC 7:", pathPart);
            return true;
        }
        if (pathPart.startsWith("//")) {
            pathPart = pathPart.substring(1);
        }
        if (/^\/[a-zA-Z]:[\\/]/.test(pathPart)) {
            pathPart = pathPart.substring(1).replace(/\\/g, "/");
            dlog("OSC 7 Windows path normalized:", pathPart);
        }
    } catch (e) {
        dlog("Invalid OSC 7 command received (parse error)", data, e);
        return true;
    }

    const validatedPath = sanitizeOsc7Path(pathPart);
    if (validatedPath == null) {
        return true;
    }

    fireAndForget(async () => {
        await services.ObjectService.UpdateObjectMeta(WOS.makeORef("block", blockId), {
            "cmd:cwd": validatedPath,
        });
        const rtInfoData: CommandSetRTInfoData = {
            oref: WOS.makeORef("block", blockId),
            data: { "shell:hascurcwd": true },
        };
        await RpcApi.SetRTInfoCommand(TabRpcClient, rtInfoData).catch((e) =>
            console.log("error setting RT info", e)
        );

        if (!tabId) {
            return;
        }
        const tabORef = WOS.makeORef("tab", tabId);
        clearOsc7Debounce(tabId);
        osc7DebounceMap.set(
            tabId,
            setTimeout(() => {
                osc7DebounceMap.delete(tabId);
                fireAndForget(async () => {
                    const currentTab = WOS.getObjectValue<Tab>(tabORef);
                    if (!currentTab) {
                        return;
                    }
                    const currentVersion = currentTab.version ?? 0;
                    const isLocked = currentTab.meta?.["tab:basedirlock"];
                    const currentBasedir = currentTab.meta?.["tab:basedir"];
                    if (isLocked) {
                        dlog("OSC 7: Skipping update - tab basedir is locked");
                        return;
                    }
                    if (currentBasedir && currentBasedir !== "~") {
                        dlog("OSC 7: Skipping update - tab basedir already explicitly set:", currentBasedir);
                        return;
                    }
                    try {
                        await services.ObjectService.UpdateObjectMetaIfNotLocked(
                            tabORef,
                            { "tab:basedir": validatedPath },
                            "tab:basedirlock",
                            currentVersion
                        );
                        const { getTabModelByTabId } = await import("@/store/tab-model");
                        const tabModel = getTabModelByTabId(tabId);
                        globalStore.set(tabModel.basedirValidationAtom, "valid");
                        globalStore.set(tabModel.lastValidationTimeAtom, Date.now());
                    } catch (err: unknown) {
                        const errMsg = err instanceof Error ? err.message : "";
                        if (errMsg.includes("version mismatch") || errMsg.includes("locked")) {
                            dlog("OSC 7: Skipped update (concurrent modification or locked)");
                            return;
                        }
                        console.log("OSC 7: Error updating tab basedir:", err);
                    }
                });
            }, OSC7_DEBOUNCE_MS)
        );
    });
    return true;
}

export function handleOsc16162Command(data: string, blockId: string, loaded: boolean, ctx: OscHandlerContext): boolean {
    const terminal = ctx.terminal;
    if (!loaded) {
        return true;
    }
    if (!data || data.length === 0) {
        return true;
    }

    const parts = data.split(";");
    const commandStr = parts[0];
    const jsonDataStr = parts.length > 1 ? parts.slice(1).join(";") : null;
    let parsedData: Record<string, unknown> = {};
    if (jsonDataStr) {
        try {
            parsedData = JSON.parse(jsonDataStr);
        } catch (e) {
            console.error("Error parsing OSC 16162 JSON data:", e);
        }
    }

    const cmd: Osc16162Command = { command: commandStr, data: parsedData } as Osc16162Command;
    const rtInfo: ObjRTInfo = {};
    switch (cmd.command) {
        case "A": {
            rtInfo["shell:state"] = "ready";
            ctx.setShellIntegrationStatus("ready");
            const marker = terminal.registerMarker(0);
            if (marker) {
                ctx.promptMarkers.push(marker);
                marker.onDispose(() => {
                    const idx = ctx.promptMarkers.indexOf(marker);
                    if (idx !== -1) {
                        ctx.promptMarkers.splice(idx, 1);
                    }
                });
            }
            break;
        }
        case "C":
            rtInfo["shell:state"] = "running-command";
            ctx.setShellIntegrationStatus("running-command");
            getApi().incrementTermCommands();
            if (cmd.data.cmd64) {
                const decodedLen = Math.ceil(cmd.data.cmd64.length * 0.75);
                if (decodedLen > 8192) {
                    rtInfo["shell:lastcmd"] = `# command too large (${decodedLen} bytes)`;
                    globalStore.set(ctx.lastCommandAtom, rtInfo["shell:lastcmd"]);
                } else {
                    try {
                        const decodedCmd = base64ToString(cmd.data.cmd64);
                        rtInfo["shell:lastcmd"] = decodedCmd;
                        globalStore.set(ctx.lastCommandAtom, decodedCmd);
                    } catch (e) {
                        console.error("Error decoding cmd64:", e);
                        rtInfo["shell:lastcmd"] = null;
                        globalStore.set(ctx.lastCommandAtom, null);
                    }
                }
            } else {
                rtInfo["shell:lastcmd"] = null;
                globalStore.set(ctx.lastCommandAtom, null);
            }
            rtInfo["shell:lastcmdexitcode"] = null;
            break;
        case "M":
            if (cmd.data.shell) {
                rtInfo["shell:type"] = cmd.data.shell;
            }
            if (cmd.data.shellversion) {
                rtInfo["shell:version"] = cmd.data.shellversion;
            }
            if (cmd.data.uname) {
                rtInfo["shell:uname"] = cmd.data.uname;
            }
            if (cmd.data.integration != null) {
                rtInfo["shell:integration"] = cmd.data.integration;
            }
            break;
        case "D":
            if (cmd.data.exitcode != null) {
                rtInfo["shell:lastcmdexitcode"] = cmd.data.exitcode;
            } else {
                rtInfo["shell:lastcmdexitcode"] = null;
            }
            break;
        case "I":
            if (cmd.data.inputempty != null) {
                rtInfo["shell:inputempty"] = cmd.data.inputempty;
            }
            break;
        case "R":
            ctx.setShellIntegrationStatus(null);
            if (terminal.buffer.active.type === "alternate") {
                terminal.write("\x1b[?1049l");
            }
            break;
    }

    if (Object.keys(rtInfo).length > 0) {
        setTimeout(() => {
            fireAndForget(async () => {
                const rtInfoData: CommandSetRTInfoData = {
                    oref: WOS.makeORef("block", blockId),
                    data: rtInfo,
                };
                await RpcApi.SetRTInfoCommand(TabRpcClient, rtInfoData).catch((e) =>
                    console.log("error setting RT info (OSC 16162)", e)
                );
            });
        }, 0);
    }

    return true;
}
